本系统作为前后端分离的营销行业管理系统，并且采用微服务分布式架构，容易扩展，方便对服务器进行集群化部署，负载能力提高，并且由于前端使用webpack打包，webpack将自动对前端页面的静态化进行优化，方便提高页面加载的速度，前端通过zuul即网关微服务请求后端的api获得数据，而不直接请求相应的微服务，方便zuul微服务根据访问流量的实时情况通过ribbon做负载均衡，为我们的零售行业的营销系统也可以适配日益扩展的企业规模。本章节通过系统各模块的设计与实现来展现整个系统的前端和后端是如何做到分离的，前端请求后端的数据格式，以及后端如何处理相应的业务逻辑。

联系人管理模块的设计与实现

联系人管理模块根据需求，可以设计出如下的页面。
搜索框联动
如图所示，最左边的栏营销人员可以从多个搜索字段中选择一个进行相应的搜素, 其中有两个栏是联动的，即营销人员在最左边栏里选择需要搜索的联系人字段，相应的，右边一个栏里会显示请输入相应字段的提示，这个功能通过vue.js的computed属性进行实现的。左边的“点击选择要搜索的字段”中的可选项通过v-for遍历fieldOptions结构，fieldOptions结构如下图所示。fieldOptions包括姓名字段、电话字段、地址字段，来源字段、创建者字段、更新者字段以及微信号字段，这些字段几乎包括了所有联系人的可搜索字段，方便传送到后台搜索微服务中进行精细搜索。fieldOptions的结构相当于一个map结构，其中key如姓名、电话等用于标签label的显示，value如name、phone用于作为field字段添加入listQuery中的字段将在之后发送到后台进行相应的搜索。


当营销人员在选择左边的一个字段如姓名时，右边的栏会显示请输入姓名，而选择电话时，右边相应的栏会显示请输入电话，实现这一点是通过vue.js中的computed属性，在联系人列表页面中的lookUp属性是通过fieldOptions动态计算生成的，由于fieldOptions确定，所以这里的lookUp属性也是确定的，lookUp在computed属性中相当于是把fieldOptions对象的key和value进行颠倒了，即fieldOptions中的key变成了lookUp中的value,而fieldOptions中的value变成了lookUp中的key，代码部分截图如下：


这样，在第二个栏中的placeholder属性可以传入lookUp[listQuery.field]就可以提取到当前已经选择的字段的对应中文名称，并且显示在placeholder属性中。
通过这样设计，每次营销人员在最左边选择一个字段field值更新为字段英文属性名，相应的营销人员再在第二个搜索栏中输入相应的要搜索的值，最后点击搜索按钮，此按钮会触发getList方法，getList方法负责把field和text的属性值拼凑成listQuery中的一个属性，方便传送到后端的SearchRequest的相应属性中，SearchRequest继承自Contact类型，拥有Contact的所有属性字段，所以，拼凑后的listQuery的json反序列化后很容易就被Spring MVC赋值到相应的SearchRequest的属性中方便搜索。

选择展示相应的属性列表
本零售行业的营销系统中还有一个很重要的功能就是可以根据营销人员的需要选择进行展示相应的字段。因为在真实的零售行业的营销管理系统中，很有可能出现字段太多，导致营销人员眼花缭乱不知道如何下手，而我们设置了相应的功能可以对属性字段进行选择展示而不是全部展示，这样将使得营销人员进行精准营销时可以更加方便。因此，本营销系统设置了一个穿梭框transfer方便营销人员根据需要显示的属性进行过滤，本营销系统的穿梭框如图所示

本穿梭框的目标列表就是选中需要显示的属性，通过v-model与data中的selectedFields进行绑定。此element ui穿梭框组件需要传入一个对象数组来告诉组件总共需要显示的属性，在本页面中是计算属性allFields提供这个对象数组，其中姓名属性、联系人ID属性、联系人姓名属性、联系人电子邮件属性的对象的disabled都为true，作用是他们只能在穿梭框的目标列表中，即必须在联系人列表中进行显示，因为一旦一个联系人没有了id、姓名将无法区分一个联系人了。在营销人员选择了属性到右边目标列表中后，并且点击确定按钮，那么selectedFields将会和filterFields进行值的传递，而本营销系统实现根据选定属性进行显示的一个关键方法就是canIDisplay，这个方法根据filterFields里的每个属性并且比较相应联系人列表上的属性名称来确定此列表是不是在穿梭框中的右边选定列表中出现，如果是出现在右边的选定列表中则表示营销人员要求显示该字段，则该字段将会在列表中进行展示，否则，营销人员不希望这个属性在列表中进行展示，此时v-if的boolean值将为false，该字段并不会在列表中进行渲染。

批量导入联系人
本零售行业的营销管理系统的另外一个重要功能就是可以根据数据导入人员的需要进行批量导入联系人，因为一旦缺失了批量导入联系人的功能，就意味着数据导入人员需要手动一个一个的填写联系人员的信息，通常，联系人的字段数量庞大，每个字段的信息又很多，对数据导入人员的效率以及公司各部门的营销机构的运行效率将带来重大的损害，所以本零售行业的营销系统必须添加批量导入联系人功能，使得数据录入人员和各部门能更快的与营销系统做数据同步。


如图所示，在联系人管理模块页面的上方有一个批量增加联系人按钮，营销人员点击此按钮，会出现一个上传界面，这个界面上将会有警告提示能够接受的文件类型，在这里由于时间问题，我们的零售行业的营销系统只对csv类型进行了兼容，营销人员点击上传按钮，通过element-ui的上传组件选定他们电脑上的csv文件路径地址并进行相应的上传，前端的vue的verify函数将会校验文件类型，如果符合csv类型，那么提交到后台联系人模块微服务进行相应的批量增加处理，否则就在页面中弹出提示文件类型不兼容，请上传csv格式的文件。


当文件传送到后台联系人模块后，后台微服务还会对相应的文件类型进行双重校验，确认是csv类型后，后台微服务通过io流对csv的每一行记录进行扫描，要注意的一点是，营销人员必须在批量增加联系人页面下载批量增加联系人模板，因为后台联系人模块微服务是按照一定的列的字段的顺序进行对联系人记录的添加的，所以营销人员自行指定列的顺序将造成联系人记录添加的混乱。

如上图所示，为后台联系人模块中批量导入联系人的时序图。联系人通过点击批量上传联系人按钮，前端校验文件格式成功后将文件发送到后台的后台联系人模块微服务ContactController类listCreate方法进行处理，此方法又会调用ContactBiz中的listCreateContacts方法对联系人的二进制流进行。ContactBiz先是通过LoadUtils中的loadContacts对二进制流进行处理，将二进制流转换成一个个联系人对象然后返回，ContactBiz类再通过forEach Lambda表达式对每一个联系人对象进行处理并调用ContactBiz中的updateContact或createContact将联系人记录添加到数据库之中去，注意ContactBiz将会根据返回的对象的情况决定调用createContact还是updateContact进行数据库的持久化，它会根据如果数据库中存在相应的联系人(根据是否存在相应的guid来判断)，就会使用updateContact更新联系人记录的信息，并且自动填写更新人和变更日期，或者就会调用createContact创建相应的联系人记录，最后通过Map集合封装状态信息传递到前端告知执行情况。特别要注意的是，LoadUtils将根据进一步的处理中的通过指定的列的顺序，并且通过列的名字通过反射设置每个Contact联系人对象的属性值。

搜索联系人
通过上文的分析，本零售行业的营销系统的前端是如何发起请求的已经很清楚了，这个小节讲解零售行业的营销系统的后端搜索微服务是如何通过前端的json字符串来进行相应的搜索操作。搜索联系人的时序图如下图所示：

如图所示，搜索微服务中的SearchController首先通过SearchRequest接收相应的前端请求信息，并且通过SearchBiz类中的searchContacts进行搜索，而SearchBiz中会还会通过其中的@Autowired聚合的类ContactRepository接口的动态代理类进行相应的查找搜索工作。需要注意的是，SearchBiz类中的searchContacts方法会通过构建一个NativeSearchQueryBuilder来构建Elasticsearch的json查询请求参数，在本功能中，我们通过QueryBuilders.match来实现关键字的搜索，需要注意的是，营销人员只会在前端的联系人界面中的搜索栏中选择联系人对象的其中一个字段进行搜索，所以在searchContacts中我们还需要判断哪个字段不为空才能进行elasticsearch的搜索。
需要特别注意的是，我们这里的营销管理系统的搜索结果是分页的，由于采用的是前后端分离的开发模式，所以数据返回的格式为如下：



添加单个联系人及后端操作逻辑：
前端实现：营销人员点击新增联系人，相应的el-dialog对话框中的v-if属性dialogFormVisible属性变成true，对话框将会在页面中显示出来，这是新增联系人方法中会调用resetTemp的方法，即将会把所有对话框中的联系人字段全部清空，因为新增联系人必须确保对话框中的字段全部为空，并且在营销人员进行联系人对象字段的填写的时候，vue.js框架会对每个填入字段进行前端的相应校验，例如当phone字段未填写的时候，phone字段校验的trigger属性为blur，这就说明当鼠标从phone字段输入框移动开之后，失去焦点，那么相应的提示信息就会在输入框旁边出现，在这里phone字段为必填，那么营销系统就会提示phone字段必填。

后端实现：后端联系人微服务的联系人添加功能模块的时序图如上图所示。前端传送联系人对象信息的json字符串在spring mvc中进行反序列化为Contact对象后送入ContactController中的createContact方法中进行处理，ContactController随后调用类中@Autowired的聚合的类ContactBiz类中的createItem进行操作，在ContactBiz类中微服务中的代码将通过System.currentTimeMillis()函数来产生当前时间的时间戳，然后填入importtime字段中去，并且设置updatetime字段为空，随后调用ContactMapper中的insertSelective实现联系人记录的持久化，此外，需要非常注意的一点是，由于最后我们零售行业的营销系统搜索的Elasticsearch的索引库而不是mysql数据库，所以接下来ContactBiz还会通过子线程调用AmpqTemplate中的convertAndSend方法发送一条消息到消息队列中去，而营销系统中的搜索微服务将接收相应的消息调用SearchBiz中的createIndex将相应的Contact对象转换成ContactSearch对象加入到Elasticsearch的索引库中去，这样就可以通过elasticsearch搜索引擎进行下一步的搜索。

删除联系人:
删除联系人操作也是零售行业的营销管理系统中不可缺少的一个功能。删除联系人，将会在前端记录相应营销人员或者数据录入人员要删除的联系人guid然后传入后端的联系人微服务模块进行相应的后续处理，删除联系人功能的时序图如下图所示：


如图所示，营销人员通过前端点击需要删除的联系人最右边的删除按钮，前端系统将会向后端联系人微服务系统发起删除请求，后端的联系人模块微服务将接收delete请求和路径参数id执行删除操作:ContactController类中的deleteContactById方法将对id进行处理，传递给ContactBiz类中的deleteItem方法中进行删除操作，需要注意的是，biz类作为业务逻辑类，为了防止操作异常等情况所造成的插入错误或者异常数据的情况，需要对每个biz类添加@Transactional注解方便开启Spring的事务管理，这样一旦操作异常，将自动撤销本操作。deleteItem方法中又会调用ContactMapper的动态代理生成实现类进行对数据库相应guid的联系人记录进行删除操作，最后返回到ContactBiz中，biz通过AmpqTemplate，异步提交一个子线程发送一条消息到RabbitMQ消息队列中告诉营销系统中的搜索微服务需要删除相应guid的，最后搜索微服务中的SearchBiz调用deleteIndex删除相应的联系人搜索索引对应guid的数据，删除联系人操作完成。

更新联系人：
更新联系人是为了方便营销人员根据自己的需要去更新相应的联系人记录，这个也是零售行业的营销系统中所不可或缺的一部分。
前端实现：在营销人员点击相应联系人的编辑按钮时就会开启更新联系人的对话框，对话框里的数据回显是通过temp对象来实现的，即每次点击某个联系人旁边的编辑按钮，相应的这行数据将会赋值给temp，而temp对象的所有属性又会渲染到这个更新联系人的对话框中。需要注意的是，在营销人员每次点击新增联系人时，temp对象的所有属性都会被重置，在前端中我们是通过resetTemp()方法来实现的，相应的后端的更新联系人的时序图如下图所示。

如上图所示，营销人员点击更新联系人并且在弹出的对话框中对自己要修改的联系人字段进行相应的修改后点击确定按钮，前端联系人页面将会发送一个json字符串到后端的联系人模块微服务中进行处理，这个json字符串即是营销人员修改后的最终temp对象的json序列化字符串。ContactController类接收到这个字符串后，通过SpringMVC的反序列化将JSON字符串反序列化成Contact对象，updateContact方法通过调用ContactBiz的updateItem方法进行操作，在updateItem中，微服务的代码将会对updatetime进行填写，即更新成当前时间的时间戳，也是通过System.currentTimeMillis()静态方法进行填写的，随后通过ContactMapper的动态代理生成类进行联系人记录的更新操作
